import logging
import os
import re
import sys
import uuid

from reddwarf.common.exception import ProcessExecutionError
from reddwarf.common import config
from reddwarf.common import utils
from reddwarf.instance import models as rd_models

LOG = logging.getLogger(__name__)


class NFS(object):
    EXPORT_FILE = '/etc/exports'
    TIME_OUT = 1000
    
    def _exec(self, *args):
        info, err = utils.execute(*args, run_as_root=True, root_helper="sudo")
        if err:
            LOG.error(err)
        else:
            return info

    def _write_to(self, mode, filename, contents):
        tmpfile = '/tmp/%s' % uuid.uuid4()
        # We dont want to copy file as root
        utils.execute('cp', filename, tmpfile)
        with open(tmpfile, mode) as f:
            f.write(contents)
        self._exec('mv', tmpfile, filename)

    def list_exports(self):
        exports = []
        with open(self.EXPORT_FILE, 'r') as f:
            for line in f:
                match = re.match('[^ ]+ ([^(]+).*', line)
                if match is not None:
                    exports.append(match.group(1))
        LOG.info("export list %s" % exports)
        # There is probably a better way to do this!
        return list(set(exports))

    def create_export(self, export_ip, export_dir='/export/users'):
        # create export and restart nfs
        parent_dir = '/'.join(export_dir.split('/')[0:-1])
        self._write_to(self.EXPORT_FILE, 'a', '%s %s(rw,fsid=0,insecure,no_subtree_check,async)\n' % (parent_dir, export_ip))
        self._write_to(self.EXPORT_FILE, 'a', '%s %s(rw,nohide,insecure,no_subtree_check,async)\n' % (export_dir, export_ip))
        self._exec("/etc/init.d/nfs-kernel-server", "restart")

    def _install_nfs(self):
        """Install NFS server."""
        LOG.debug(_("Installing NFS server"))
        self.pkg_install("nfs-kernel-server", self.TIME_OUT)

    def _create_exports(self, export_dir, home_dir):
        # Create export dir
        self._exec("mkdir", "-p", export_dir)
        # Now chmod 777 so export_dir is world writable, in a real
        # world scenario, we would use ldap here. this is Proof of Concept
        self._exec("chmod", "777", export_dir)
        # Create homedir
        self._exec("mkdir", "-p", home_dir)
        # Mount homedir
        self._exec("mount", "--bind", home_dir, export_dir)
        # Write to the fstab to save on boot
        self._write_to('/etc/fstab', 'a','%s    %s   none    bind  0  0' % (home_dir, export_dir))
        # Overwrite the existing exports
        self._write_to('/etc/exports', 'w', '#Autogenerated')

    def _write_configs(self):
        # Write configs for nfs server
        self._exec('sed', '-i', 's/NEED_SVCGSSD=/NEED_SVCGSSD=no/g', '/etc/default/nfs-kernel-server')
        self._exec('sed', '-i', 's/NEED_IDMAPD=/NEED_IDMAPD=yes/g', '/etc/default/nfs-common')
        self._exec('sed', '-i', 's/NEED_GSSD=/NEED_GSSD=no/g', '/etc/default/nfs-common')

    def prepare(self, databases, memory_mb):
        """Installs a nfs server. """
        #apt-get install nfs-kernel-server 
        LOG.info(_("Preparing Guest as NFS Server"))
        from reddwarf.guestagent.pkg import PkgAgent
        if not isinstance(self, PkgAgent):
            raise TypeError("This must also be an instance of Pkg agent.")
        try:
            self._exec("apt-get", "update")
        except Process_executionError as e:
            LOG.error(_("Error updating the apt sources"))

        self._install_nfs()
        self._create_exports('/export/users', '/home/users')
        self._write_configs()
        
        self.update_status()

    def update_status(self):
        id = config.Config.get('guest_id')
        status = rd_models.InstanceServiceStatus.find_by(instance_id=id)

        try:
            out = self._exec("/etc/init.d/nfs-kernel-server", "status")
            if "running" in out:
                status.set_status(rd_models.ServiceStatuses.RUNNING)
            else:
                status.set_status(rd_models.ServiceStatuses.SHUTDOWN)
            status.save()
        except ProcessExecutionError as e:
            status.set_status(rd_models.ServiceStatuses.SHUTDOWN)
            status.save()
